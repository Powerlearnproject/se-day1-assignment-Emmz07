[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18375901&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software. Instead of just writing code randomly, it follows a set of rules, best practices, structured methodology, tools, and processes to make sure the software works well, is easy to maintain, and can grow when needed.

Some importance of software engineering in technology industry are;
- Enabling reliablility and software quality to create high-quality, bug-free, and secure applications. This ensures that users can trust software to function correctly, whether it's a banking app, an e-commerce platform, or a social media network.
- Reduction in cost and development time by minimizing errors, avoiding rework, and speeding up development. This saves both time and money, allowing businesses to launch products faster and remain competitive.
- Supporting innovation and emerging technologies for structural development so as to be reliable and effective.
- Improving security and to protect sensitive data from being hacked, to ensure compliance with industry regulations, keeping both users and businesses safe. 

Identify and describe at least three key milestones in the evolution of software engineering.

i) The Birth of Software Engineering (1968 - NATO Conference)
Before 1968, software development lacked structure, leading to frequent project failures, cost overruns, and delays—this was known as the "Software Crisis.". The NATO Software Engineering Conference introduced the term software engineering and emphasized systematic development methodologies, structured programming, and software lifecycle management.

ii) The Rise of Object-Oriented Programming (OOP) (1980s - 1990s)
As software systems grew larger, code reusability and modularity became crucial. Object-Oriented Programming (OOP) introduced concepts like encapsulation, inheritance, and polymorphism, making it easier to manage complex systems.Languages like C++, Java, and Python popularized OOP, allowing developers to create scalable and maintainable applications.

iii) DevOps and Continuous Integration/Continuous Deployment (CI/CD) (2010s - Present)
DevOps emerged as a culture and methodology that combines development (Dev) and operations (Ops) to streamline software delivery.

List and briefly explain the phases of the Software Development Life Cycle.

1. Planning
This is the initial phase where project goals, scope, budget, timeline, and feasibility are analyzed.
Key stakeholders define requirements and expectations to ensure project success.

2. Requirements Analysis
In this phase, developers gather and document functional and non-functional requirements based on user needs.Techniques such as interviews, surveys, and document analysis are used to understand what the software must achieve.

3. Design
The system’s architecture, user interface, database, and technical specifications are designed in this phase.The software is broken down into modules, and data flow diagrams (DFDs), entity-relationship diagrams (ERDs), and wireframes are created.
High-level design (HLD) outlines overall system architecture, while low-level design (LLD) details specific module designs.

5. Implementation (Coding)
This is the phase where actual coding takes place based on the design specifications.
Developers use programming languages like Java, Python, C++, or JavaScript to write code.
Version control systems like Git help manage code changes.

7. Testing
The software is tested to identify and fix bugs, security vulnerabilities, and performance issues.
Different testing methods include:
Unit Testing (testing individual components)
Integration Testing (checking how modules interact)
System Testing (verifying the whole system)
User Acceptance Testing (UAT) (ensuring it meets user expectations).

9. Deployment
After successful testing, the software is released to users. Deployment can be done in different ways:
Full deployment (releasing to all users at once)
Phased deployment (releasing in stages)
Beta testing (allowing select users to test before full release)
Cloud platforms like AWS,Vercel, Azure, and Google Cloud are often used for deployment.

10. Maintenance & Support
After deployment, developers provide updates, bug fixes, and performance enhancements.
Three types of maintenance exist:
Corrective Maintenance (fixing bugs and errors)
Adaptive Maintenance (modifying the software for new environments)
Perfective Maintenance (adding new features or improving performance).


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Waterfall is a step-by-step process where each phase is completed before moving to the next.
It follows a strict order:
Requirement Gathering → Design → Implementation (Coding) → Testing → Deployment → Maintenance
There is no going back to previous phases once completed. Works well when all requirements are known upfront and little to no changes are expected.
Example: Building a bridge – You must plan everything before construction begins.

While,
Agile breaks the project into smaller parts (sprints), each delivering a working product increment.
Instead of completing the entire software at once, teams develop, test, and refine continuously.
Agile embraces changing requirements, allowing modifications at any stage based on feedback.
It follows a loop: Plan → Design → Develop → Test → Get Feedback → Improve
Example: Developing a mobile app – Features are released in updates based on user feedback.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

A Software Developer is responsible for designing, coding, and implementing software applications based on project requirements.

A Quality Assurance Engineer ensures that the software meets quality standards by identifying and fixing defects before deployment.

A Project Manager oversees the software development process, ensuring the project stays on schedule, within budget, and meets requirements.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

IDEs provide a centralized platform that combines multiple development tools, making coding, debugging, and testing more efficient. They improve productivity by offering features like syntax highlighting, code completion, debugging tools, and project management support. An example is Visual Studio Code (VS Code), A lightweight, extensible IDE with strong extensions.

A VCS helps teams track, manage, and coordinate changes in source code. It ensures collaboration, version tracking, and backup of code, making development more organized and reducing the risk of losing work. An example of a VCS is Git, The most widely used VCS, allowing distributed version control. Often used with platforms like GitHub, GitLab, and Bitbucket.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

i) Debugging Complex Code
Solution: Use debugging tools, write unit tests, and follow log-based debugging to identify issues efficiently.
ii) Keeping Up with New Technologies : Rapid advancements in technology make it difficult to stay updated.
Solution: Follow tech blogs, take online courses, and participate in developer communities.
iii)  Managing Tight Deadlines and Delivering quality software under strict time constraints.
Solution: Use Agile methodologies, prioritize tasks, and break work into manageable sprints.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1. Unit Testing
This tests individual components (functions, methods) in isolation. It ensures each module works correctly before integration.
Importance: Detects bugs early, reducing debugging time later.

2. Integration Testing
It tests how different modules interact when combined and identifies issues in data flow and API communication.
Importance: Prevents integration failures between components.

3. System Testing
System Testing tests the entire application as a complete system and also ensures all components work together as expected.
Importance: Validates functionality, performance, and security.

4. Acceptance Testing (also known as UAT - User Acceptance Testing)
Conducted by end-users to validate if software meets business requirements and to ensures usability, compliance, and customer satisfaction.
Importance: Confirms the product is ready for deployment.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the art and science of crafting effective prompts (questions or instructions) to guide AI models in generating accurate, relevant, and meaningful responses. It involves structuring prompts strategically to improve the quality of AI-generated outputs.

Some importance of Prompt Engineering in AI Interaction are;
Enhances AI Accuracy – Well-structured prompts ensure AI understands the query correctly, leading to better responses.
Improves Efficiency – Reduces the need for multiple attempts by getting the desired answer on the first try.
Customizes AI Behavior – Adjusting tone, style, and specificity makes AI responses more tailored to user needs.
Optimizes Productivity – Helps developers, writers, and researchers use AI effectively for coding, content creation, and problem-solving.
Reduces Bias & Errors – Carefully designed prompts minimize misunderstandings and ensure ethical AI outputs.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
